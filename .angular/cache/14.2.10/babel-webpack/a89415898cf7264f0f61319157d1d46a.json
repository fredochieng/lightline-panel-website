{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport { elementScroll } from \"./scroll.js\"; // https://drafts.csswg.org/css-writing-modes-4/#block-flow\n\nconst normalizeWritingMode = writingMode => {\n  switch (writingMode) {\n    case \"horizontal-tb\":\n    case \"lr\":\n    case \"lr-tb\":\n    case \"rl\":\n    case \"rl-tb\":\n      return 0\n      /* HorizontalTb */\n      ;\n\n    case \"vertical-rl\":\n    case \"tb\":\n    case \"tb-rl\":\n      return 1\n      /* VerticalRl */\n      ;\n\n    case \"vertical-lr\":\n    case \"tb-lr\":\n      return 2\n      /* VerticalLr */\n      ;\n\n    case \"sideways-rl\":\n      return 3\n      /* SidewaysRl */\n      ;\n\n    case \"sideways-lr\":\n      return 4\n      /* SidewaysLr */\n      ;\n  }\n\n  return 0\n  /* HorizontalTb */\n  ;\n};\n\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n  /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n  let layout = 0b00;\n  /**\n   * WritingMode.VerticalLr: ↓→\n   * | 1 | 4 |   |\n   * | 2 | 5 |   |\n   * | 3 |   |   |\n   *\n   * RTL: ↑→\n   * | 3 |   |   |\n   * | 2 | 5 |   |\n   * | 1 | 4 |   |\n   */\n\n  if (!isLTR) {\n    layout ^= 2\n    /* ReverseVertical */\n    ;\n  }\n\n  switch (writingMode) {\n    /**\n     * ↓→\n     * | 1 | 2 | 3 |\n     * | 4 | 5 |   |\n     * |   |   |   |\n     *\n     * RTL: ↓←\n     * | 3 | 2 | 1 |\n     * |   | 5 | 4 |\n     * |   |   |   |\n     */\n    case 0\n    /* HorizontalTb */\n    :\n      // swap horizontal and vertical\n      layout = layout >> 1 | (layout & 1) << 1;\n      [hPos, vPos] = [vPos, hPos];\n      break;\n\n    /**\n     * ↓←\n     * |   | 4 | 1 |\n     * |   | 5 | 2 |\n     * |   |   | 3 |\n     *\n     * RTL: ↑←\n     * |   |   | 3 |\n     * |   | 5 | 2 |\n     * |   | 4 | 1 |\n     */\n\n    case 1\n    /* VerticalRl */\n    :\n    case 3\n    /* SidewaysRl */\n    :\n      //  reverse horizontal\n      layout ^= 1\n      /* ReverseHorizontal */\n      ;\n      break;\n\n    /**\n     * ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     *\n     * RTL: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     */\n\n    case 4\n    /* SidewaysLr */\n    :\n      // reverse vertical\n      layout ^= 2\n      /* ReverseVertical */\n      ;\n      break;\n  }\n\n  return [layout, hPos, vPos];\n};\n\nconst isXReversed = computedStyle => {\n  const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n  return (layout & 1) === 1;\n}; // https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\n\n\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n  const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n  return [hPos, vPos].map((value, index) => {\n    switch (value) {\n      case \"center\":\n        return 1\n        /* CenterAlways */\n        ;\n\n      case \"nearest\":\n        return 0\n        /* ToEdgeIfNeeded */\n        ;\n\n      default:\n        {\n          const reverse = layout >> index & 1;\n          return value === \"start\" === !reverse ? 2\n          /* LeftOrTop */\n          : 3\n          /* RightOrBottom */\n          ;\n        }\n    }\n  });\n}; // code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\n\n\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n  if (align !== 0\n  /* ToEdgeIfNeeded */\n  ) {\n    return align;\n  }\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓\n   *          │  │\n   *        ┃ │  │ ┃        do nothing\n   *          │  │\n   *        ┗━│━━│━┛\n   *          └──┘\n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *    ┏ ━ ━ ━ ━ ┓\n   *   ┌───────────┐\n   *   │┃         ┃│        do nothing\n   *   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛\n   */\n\n\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return null;\n  }\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓         ┏━┌━━┐━┓\n   *          └──┘             │  │\n   *  from  ┃      ┃     to  ┃ └──┘ ┃\n   *\n   *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n   *                           │  │\n   *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n   *          │  │             │  │\n   *        ┗━│━━│━┛         ┗━│━━│━┛\n   *          │  │             └──┘\n   *          │  │\n   *          └──┘\n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───┐                 ┌───┐\n   *  │ ┃ │       ┃         ┃   │     ┃\n   *  └───┘                 └───┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *        ┌───────────┐   ┌───────────┐\n   *    ┃   │     ┃     │   ┃         ┃ │\n   *        └───────────┘   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   */\n\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return 2\n    /* LeftOrTop */\n    ;\n  }\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n   *\n   *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n   *          ┌──┐             │  │\n   *        ┗━│━━│━┛         ┗━└━━┘━┛\n   *          └──┘\n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          ┌──┐\n   *          │  │\n   *          │  │             ┌──┐\n   *        ┏━│━━│━┓         ┏━│━━│━┓\n   *          │  │             │  │\n   *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n   *                           │  │\n   *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───────────┐           ┌───────────┐\n   *  │     ┃     │   ┃       │ ┃         ┃\n   *  └───────────┘           └───────────┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *                ┌───┐             ┌───┐\n   *        ┃       │ ┃ │       ┃     │   ┃\n   *                └───┘             └───┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   */\n\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return 3\n    /* RightOrBottom */\n    ;\n  }\n\n  return null;\n};\n\nconst canOverflow = overflow => {\n  return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = element => {\n  var _a;\n\n  try {\n    return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n  } catch (_b) {\n    return null;\n  }\n};\n\nconst isScrollable = (element, computedStyle) => {\n  if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n    return canOverflow(computedStyle.overflowY) || canOverflow(computedStyle.overflowX) || element === scrollingElement(element);\n  }\n\n  return false;\n};\n\nconst parentElement = element => {\n  const pNode = element.parentNode;\n  const pElement = element.parentElement;\n\n  if (pElement === null && pNode !== null) {\n    if (pNode.nodeType ===\n    /** Node.DOCUMENT_FRAGMENT_NODE */\n    11) {\n      return pNode.host;\n    }\n\n    if (pNode.nodeType ===\n    /** Node.DOCUMENT_NODE */\n    9) {\n      return getFrameElement(element);\n    }\n  }\n\n  return pElement;\n};\n\nconst clamp = (value, min, max) => {\n  if (value < min) {\n    return min;\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  return value;\n};\n\nconst getSupportedScrollMarginProperty = ownerDocument => {\n  // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n  return [\"scroll-margin\", \"scroll-snap-margin\"].filter(property => property in ownerDocument.documentElement.style)[0];\n};\n\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = elementRect;\n  const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n\n  if (!scrollProperty) {\n    return [top, right, bottom, left];\n  }\n\n  const scrollMarginValue = edge => {\n    const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n    return parseInt(value, 10) || 0;\n  };\n\n  return [top - scrollMarginValue(\"top\"), right + scrollMarginValue(\"right\"), bottom + scrollMarginValue(\"bottom\"), left - scrollMarginValue(\"left\")];\n};\n\nconst calcAlignEdge = (align, start, end) => {\n  switch (align) {\n    case 1\n    /* CenterAlways */\n    :\n      return (start + end) / 2;\n\n    case 3\n    /* RightOrBottom */\n    :\n      return end;\n\n    case 2\n    /* LeftOrTop */\n    :\n    case 0\n    /* ToEdgeIfNeeded */\n    :\n      return start;\n  }\n};\n\nconst getFrameViewport = (frame, frameRect) => {\n  var _a, _b, _c;\n\n  const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n  const [x, y, width, height] = frame === scrollingElement(frame) ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight] : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n  const left = x + frame.clientLeft;\n  const top = y + frame.clientTop;\n  const right = left + width;\n  const bottom = top + height;\n  return [top, right, bottom, left];\n};\n\nconst computeScrollIntoView = (element, options) => {\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const actions = [];\n  let ownerDocument = element.ownerDocument;\n  let ownerWindow = ownerDocument.defaultView;\n\n  if (!ownerWindow) {\n    return actions;\n  }\n\n  const computedStyle = window.getComputedStyle(element);\n  const isLTR = computedStyle.direction !== \"rtl\";\n  const writingMode = normalizeWritingMode(computedStyle.writingMode || computedStyle.getPropertyValue(\"-webkit-writing-mode\") || computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n  const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n  let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n  for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n    if (ownerDocument !== frame.ownerDocument) {\n      ownerDocument = frame.ownerDocument;\n      ownerWindow = ownerDocument.defaultView;\n\n      if (!ownerWindow) {\n        break;\n      }\n\n      const {\n        left: dX,\n        top: dY\n      } = frame.getBoundingClientRect();\n      top += dY;\n      right += dX;\n      bottom += dY;\n      left += dX;\n    }\n\n    const frameStyle = ownerWindow.getComputedStyle(frame);\n\n    if (frameStyle.position === \"fixed\") {\n      break;\n    }\n\n    if (!isScrollable(frame, frameStyle)) {\n      continue;\n    }\n\n    const frameRect = frame.getBoundingClientRect();\n    const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n    const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n    const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n    const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n    const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n    const moveX = isXReversed(frameStyle) ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft) : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n    const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n    actions.push([frame, {\n      left: frame.scrollLeft + moveX,\n      top: frame.scrollTop + moveY,\n      behavior: options.behavior\n    }]);\n    top = Math.max(top - moveY, frameTop);\n    right = Math.min(right - moveX, frameRight);\n    bottom = Math.min(bottom - moveY, frameBottom);\n    left = Math.max(left - moveX, frameLeft);\n  }\n\n  return actions;\n};\n\nexport const scrollIntoView = (element, scrollIntoViewOptions, config) => {\n  const options = scrollIntoViewOptions || {};\n\n  if (!checkBehavior(options.behavior)) {\n    throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n  }\n\n  const actions = computeScrollIntoView(element, options);\n  actions.forEach(([frame, scrollToOptions]) => {\n    elementScroll(frame, scrollToOptions, config);\n  });\n};\nexport const elementScrollIntoView = scrollIntoView;","map":{"version":3,"names":["checkBehavior","failedExecuteInvalidEnumValue","scrollingElement","elementScroll","normalizeWritingMode","writingMode","calcPhysicalAxis","isLTR","hPos","vPos","layout","isXReversed","computedStyle","direction","undefined","toPhysicalAlignment","options","block","inline","map","value","index","reverse","mapNearest","align","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","elementEdgeStart","elementEdgeEnd","elementSize","canOverflow","overflow","getFrameElement","element","_a","ownerDocument","defaultView","frameElement","_b","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","parentElement","pNode","parentNode","pElement","nodeType","host","clamp","min","max","getSupportedScrollMarginProperty","filter","property","documentElement","style","getElementScrollSnapArea","elementRect","top","right","bottom","left","scrollProperty","scrollMarginValue","edge","getPropertyValue","parseInt","calcAlignEdge","start","end","getFrameViewport","frame","frameRect","_c","visualViewport","x","y","width","height","clientLeft","clientTop","computeScrollIntoView","actions","ownerWindow","window","getComputedStyle","alignH","alignV","getBoundingClientRect","dX","dY","frameStyle","position","frameTop","frameRight","frameBottom","frameLeft","eAlignH","eAlignV","diffX","diffY","moveX","scrollLeft","moveY","scrollTop","push","behavior","Math","scrollIntoView","scrollIntoViewOptions","config","TypeError","forEach","scrollToOptions","elementScrollIntoView"],"sources":["D:/Projects/Lightline/panel_site - Copy (2)/node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport { elementScroll } from \"./scroll.js\";\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return 0 /* HorizontalTb */;\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return 1 /* VerticalRl */;\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return 2 /* VerticalLr */;\n        case \"sideways-rl\":\n            return 3 /* SidewaysRl */;\n        case \"sideways-lr\":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return 1 /* CenterAlways */;\n            case \"nearest\":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return [\"scroll-margin\", \"scroll-snap-margin\"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n        computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nexport const scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nexport const elementScrollIntoView = scrollIntoView;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}